### 设计模式

* 单例模式

  > 饿汉方式
  >
  > 懒汉方式
  >
  > Double检查
  >
  > 静态内部类
  >
  > 枚举
  >
  > 容器
  >
  > 注意两种破坏单例的方式
  >
  > * 通过反射
  > * 通过序列化和反序列化

* 原型模式

  > 和单例正好是相反的，单例是无论如何都要保证实例唯一，但原型是在原有的基础上进行对象复制，简化new对象的复杂性
  >
  > clone
  >
  > 实现Cloneable接口的都是浅克隆

* 工厂模式

  > 简单工厂
  >
  > 工厂方法（工厂的工厂）
  >
  > 抽象工厂（简单工厂的抽象）

* 建造者

  > build 变成链式操作，关键点builder返回this
  >
  > 以上4种都是属于建造者模式

* 代理模式

  * 静态代理

    > 其实分层结构中的Action中嵌入的Service，Service中嵌入的DAO,都属于静态代理的形式

  * 动态代理

    > JDK 基于接口和反射实现的，所以性能略差，实现InvocationHandler即可。
    >
    > CGLIB 基于继承实现的，性能比JDK要好，需要引入cglib包，以及实现接口 MethodInterceptor
    >
    > spring默认使用JDK动态代理，如果类没有接口，则使用CGLIB